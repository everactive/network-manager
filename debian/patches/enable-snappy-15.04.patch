Index: nm-snappy-support/src/main.c
===================================================================
--- nm-snappy-support.orig/src/main.c
+++ nm-snappy-support/src/main.c
@@ -70,6 +70,9 @@ static GMainLoop *main_loop = NULL;
 static gboolean quit_early = FALSE;
 static sigset_t signal_set;
 
+extern const char* get_snap_app_path();
+extern const char* get_snap_app_data_path();
+
 void *signal_handling_thread (void *arg);
 /*
  * Thread function waiting for signals and processing them.
@@ -355,6 +358,7 @@ main (int argc, char *argv[])
 	GError *error = NULL;
 	gboolean wrote_pidfile = FALSE;
 	char *bad_domains = NULL;
+	char *run_dir, *state_dir;
 
 	GOptionEntry options[] = {
 		{ "version", 'V', 0, G_OPTION_ARG_NONE, &show_version, N_("Print NetworkManager version and exit"), NULL },
@@ -476,18 +480,37 @@ main (int argc, char *argv[])
 		g_free (path);
 	}
 
+	if (get_snap_app_data_path()) {
+		run_dir = g_strdup_printf("%s/var/run/", get_snap_app_data_path());
+		state_dir = g_strdup_printf("%s/var/lib/", get_snap_app_data_path());
+	} else {
+		run_dir = g_strdup (NMRUNDIR);
+		state_dir = g_strdup (NMSTATEDIR);
+	}
+
+	nm_log_warn (LOGD_CORE, "run_dir: '%s", run_dir);
+	nm_log_warn (LOGD_CORE, "state_dir: '%s", state_dir);
+
 	/* Setup runtime directory */
-	if (g_mkdir_with_parents (NMRUNDIR, 0755) != 0) {
-		nm_log_err (LOGD_CORE, "Cannot create '%s': %s", NMRUNDIR, strerror (errno));
+	if (g_mkdir_with_parents (run_dir, 0755) != 0) {
+		nm_log_err (LOGD_CORE, "Cannot create '%s': %s", run_dir, strerror (errno));
+		g_free (run_dir);
+		g_free (state_dir);
 		exit (1);
 	}
 
+	g_free (run_dir);
+
 	/* Ensure state directory exists */
-	if (g_mkdir_with_parents (NMSTATEDIR, 0755) != 0) {
-		nm_log_err (LOGD_CORE, "Cannot create '%s': %s", NMSTATEDIR, strerror (errno));
+	if (g_mkdir_with_parents (state_dir, 0755) != 0) {
+		nm_log_err (LOGD_CORE, "Cannot create '%s': %s", state_dir, strerror (errno));
+		g_free (run_dir);
+		g_free (state_dir);
 		exit (1);
 	}
 
+	g_free (state_dir);
+
 	pidfile = pidfile ? pidfile : g_strdup (NM_DEFAULT_PID_FILE);
 	state_file = state_file ? state_file : g_strdup (NM_DEFAULT_SYSTEM_STATE_FILE);
 
@@ -561,7 +584,10 @@ main (int argc, char *argv[])
 		g_log_set_always_fatal (fatal_mask);
 	}
 
+	/* FIXME: this causes us to segfault in a snappy environment */
+#if 0
 	nm_logging_syslog_openlog (debug);
+#endif
 
 #if !GLIB_CHECK_VERSION (2, 35, 0)
 	g_type_init ();
@@ -593,6 +619,7 @@ main (int argc, char *argv[])
 
 	/* Initialize our DBus service & connection */
 	dbus_mgr = nm_dbus_manager_get ();
+
 	g_assert (dbus_mgr != NULL);
 
 	vpn_manager = nm_vpn_manager_get ();
Index: nm-snappy-support/src/settings/nm-settings.c
===================================================================
--- nm-snappy-support.orig/src/settings/nm-settings.c
+++ nm-snappy-support/src/settings/nm-settings.c
@@ -124,6 +124,7 @@ static void connection_provider_init (NM
 G_DEFINE_TYPE_EXTENDED (NMSettings, nm_settings, G_TYPE_OBJECT, 0,
                         G_IMPLEMENT_INTERFACE (NM_TYPE_CONNECTION_PROVIDER, connection_provider_init))
 
+extern const char* get_snap_app_path();
 
 typedef struct {
 	NMDBusManager *dbus_mgr;
@@ -615,6 +616,15 @@ load_plugins (NMSettings *self, const ch
 	const char **iter;
 	gboolean keyfile_added = FALSE;
 	gboolean success = TRUE;
+	char *plugin_dir = NULL;
+
+	if (get_snap_app_path()) {
+		plugin_dir = g_strdup_printf ("%s/usr/lib/x86_64-linux-gnu/NetworkManager/", get_snap_app_path());
+	}
+	else
+		plugin_dir = g_strdup (NMPLUGINDIR);
+
+   	nm_log_warn (LOGD_HW, "load_plugins: about to open plugin directory %s", plugin_dir);
 
 	for (iter = plugins; iter && *iter; iter++) {
 		GModule *plugin;
@@ -645,7 +655,7 @@ load_plugins (NMSettings *self, const ch
 		}
 
 		full_name = g_strdup_printf ("nm-settings-plugin-%s", pname);
-		path = g_module_build_path (NMPLUGINDIR, full_name);
+		path = g_module_build_path (plugin_dir, full_name);
 
 		plugin = g_module_open (path, G_MODULE_BIND_LOCAL);
 		if (!plugin) {
@@ -690,6 +700,9 @@ load_plugins (NMSettings *self, const ch
 
 	g_slist_free_full (list, g_object_unref);
 
+	if (plugin_dir)
+		g_free (plugin_dir);
+
 	return success;
 }
 
@@ -1754,6 +1767,8 @@ nm_settings_new (GError **error)
 	NMSettings *self;
 	NMSettingsPrivate *priv;
 
+   	nm_log_warn (LOGD_HW, "nm_settings_new");
+
 	self = g_object_new (NM_TYPE_SETTINGS, NULL);
 
 	priv = NM_SETTINGS_GET_PRIVATE (self);
@@ -1761,8 +1776,11 @@ nm_settings_new (GError **error)
 	priv->config = nm_config_get ();
 	priv->dbus_mgr = nm_dbus_manager_get ();
 
+   	nm_log_warn (LOGD_HW, "nm_settings_new: about to call load_plugins");
+
 	/* Load the plugins; fail if a plugin is not found. */
 	if (!load_plugins (self, nm_config_get_plugins (priv->config), error)) {
+		fprintf (stderr, "load settings plugins - FAILED!!!\n");
 		g_object_unref (self);
 		return NULL;
 	}
Index: nm-snappy-support/src/nm-manager.c
===================================================================
--- nm-snappy-support.orig/src/nm-manager.c
+++ nm-snappy-support/src/nm-manager.c
@@ -157,6 +157,8 @@ static gboolean find_master (NMManager *
 
 static void nm_manager_update_state (NMManager *manager);
 
+extern const char* get_snap_app_path();
+
 #define SSD_POKE_INTERVAL 120
 #define ORIGDEV_TAG "originating-device"
 
@@ -2023,13 +2025,25 @@ load_device_factories (NMManager *self)
 	const char *item;
 	char *path;
 	GSList *iter;
+	char *plugin_dir;
+
+	/* FIXME: hard-coded arch path... */
+	if (get_snap_app_path())
+		plugin_dir = g_strdup_printf("%s/usr/lib/x86_64-linux-gnu/NetworkManager/",
+					     get_snap_app_path());
+	else
+		plugin_dir = g_strdup (NMPLUGINDIR);
+
+   	nm_log_warn (LOGD_HW, "load_device_factories: about to open plugin directory %s", plugin_dir);
+
+	dir = g_dir_open (plugin_dir, 0, &error);
 
-	dir = g_dir_open (NMPLUGINDIR, 0, &error);
 	if (!dir) {
 		nm_log_warn (LOGD_HW, "Failed to open plugin directory %s: %s",
-		             NMPLUGINDIR,
+		             plugin_dir,
 		             (error && error->message) ? error->message : "(unknown)");
 		g_clear_error (&error);
+		g_free (plugin_dir);
 		return;
 	}
 
@@ -2046,7 +2060,11 @@ load_device_factories (NMManager *self)
 		if (g_str_has_suffix (item, ".la"))
 			continue;
 
-		path = g_module_build_path (NMPLUGINDIR, item);
+		if (get_snap_app_path())
+			path = g_module_build_path(plugin_dir, item);
+		else
+			path = g_module_build_path (NMPLUGINDIR, item);
+
 		g_assert (path);
 		plugin = g_module_open (path, G_MODULE_BIND_LOCAL);
 		g_free (path);
@@ -2114,8 +2132,11 @@ load_device_factories (NMManager *self)
 		nm_log_info (LOGD_HW, "Loaded device plugin: %s", g_module_name (plugin));
 	};
 	g_dir_close (dir);
+	g_free (plugin_dir);
 
 	priv->factories = g_slist_reverse (priv->factories);
+
+   	nm_log_warn (LOGD_HW, "load_device_factories: all done");
 }
 
 static void
Index: nm-snappy-support/src/nm-activation-request.c
===================================================================
--- nm-snappy-support.orig/src/nm-activation-request.c
+++ nm-snappy-support/src/nm-activation-request.c
@@ -45,6 +45,8 @@ G_DEFINE_TYPE (NMActRequest, nm_act_requ
                                        NM_TYPE_ACT_REQUEST, \
                                        NMActRequestPrivate))
 
+extern const char* get_snap_app_path();
+
 typedef struct {
 	char *table;
 	char *rule;
@@ -228,8 +230,13 @@ nm_act_request_set_shared (NMActRequest
 		char *envp[1] = { NULL };
 		gs_strfreev char **argv = NULL;
 		gs_free char *cmd = NULL;
+		char *base_path = "";
+
+		if (get_snap_app_path())
+			base_path = get_snap_app_path();
 
-		cmd = g_strdup_printf ("%s --table %s %s %s",
+		cmd = g_strdup_printf ("%s%s --table %s %s %s",
+		                       base_path,
 		                       IPTABLES_PATH,
 		                       rule->table,
 		                       shared ? "--insert" : "--delete",
Index: nm-snappy-support/src/devices/nm-device.c
===================================================================
--- nm-snappy-support.orig/src/devices/nm-device.c
+++ nm-snappy-support/src/devices/nm-device.c
@@ -85,6 +85,8 @@ G_DEFINE_ABSTRACT_TYPE_WITH_CODE (NMDevi
 
 #define NM_DEVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DEVICE, NMDevicePrivate))
 
+const char* get_snap_app_path();
+
 enum {
 	STATE_CHANGED,
 	AUTOCONNECT_ALLOWED,
@@ -4454,6 +4456,12 @@ send_arps (NMDevice *self, const char *m
 	NMIP4Address *addr;
 	guint32 ipaddr;
 	GError *error = NULL;
+	char *path = NULL;
+
+	if (get_snap_app_path()) {
+		path = g_strdup_printf("%s/usr/bin/arping", get_snap_app_path());
+		argv[0] = path;
+	}
 
 	connection = nm_device_get_connection (self);
 	if (!connection)
@@ -4482,6 +4490,9 @@ send_arps (NMDevice *self, const char *m
 			g_clear_error (&error);
 		}
 	}
+
+	if (path)
+		g_free(path);
 }
 
 static gboolean
Index: nm-snappy-support/src/dhcp-manager/nm-dhcp-dhclient.c
===================================================================
--- nm-snappy-support.orig/src/dhcp-manager/nm-dhcp-dhclient.c
+++ nm-snappy-support/src/dhcp-manager/nm-dhcp-dhclient.c
@@ -45,6 +45,9 @@
 
 G_DEFINE_TYPE (NMDHCPDhclient, nm_dhcp_dhclient, NM_TYPE_DHCP_CLIENT)
 
+extern const char* get_snap_app_path();
+extern const char* get_snap_app_data_path();
+
 #define NM_DHCP_DHCLIENT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DHCP_DHCLIENT, NMDHCPDhclientPrivate))
 
 typedef struct {
@@ -99,9 +102,14 @@ get_dhclient_leasefile (const char *ifac
                         char **out_preferred_path)
 {
 	char *path;
+	char *base_path = NMSTATEDIR;
+
+	if (get_snap_app_data_path())
+		base_path = get_snap_app_data_path();
 
 	/* /var/lib/NetworkManager is the preferred leasefile path */
-	path = g_strdup_printf (NMSTATEDIR "/dhclient%s-%s-%s.lease",
+	path = g_strdup_printf ("%s/dhclient%s-%s-%s.lease",
+	                        base_path,
 	                        ipv6 ? "6" : "",
 	                        uuid,
 	                        iface);
@@ -276,12 +284,16 @@ create_dhclient_config (const char *ifac
                         const char *hostname)
 {
 	char *orig = NULL, *new = NULL;
+	char *base_path = NMSTATEDIR;
 	GError *error = NULL;
 	gboolean success = FALSE;
 
 	g_return_val_if_fail (iface != NULL, NULL);
 
-	new = g_strdup_printf (NMSTATEDIR "/dhclient%s-%s.conf", is_ip6 ? "6" : "", iface);
+	if (get_snap_app_data_path())
+		base_path = get_snap_app_data_path();
+
+	new = g_strdup_printf ("%s/dhclient%s-%s.conf", base_path, is_ip6 ? "6" : "", iface);
 	nm_log_dbg (is_ip6 ? LOGD_DHCP6 : LOGD_DHCP4,
 	            "(%s): creating composite dhclient config %s",
 	            iface, new);
@@ -605,8 +617,15 @@ nm_dhcp_dhclient_init (NMDHCPDhclient *s
 {
 	NMDHCPDhclientPrivate *priv = NM_DHCP_DHCLIENT_GET_PRIVATE (self);
 	const char **iter = &def_leasefiles[0];
+	char *dhclient_path = DHCLIENT_PATH;
+
+	if (get_snap_app_path())
+		dhclient_path = g_strdup_printf("%s/sbin/dhclient", get_snap_app_path());
+
+	priv->path = nm_dhcp_dhclient_get_path (dhclient_path);
 
-	priv->path = nm_dhcp_dhclient_get_path (DHCLIENT_PATH);
+	if (get_snap_app_data_path())
+		g_free(dhclient_path);
 
 	while (iter && *iter) {
 		if (g_file_test (*iter, G_FILE_TEST_EXISTS)) {
